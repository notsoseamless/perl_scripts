#! /usr/bin/perl
#perl2exe_include Cwd
#perl2exe_include "C:\Perl\lib\Cwd.pm"

################################################################################
# File Name :
#          generate_filelist_v2.0.pl
#
# Version   :
#          2.0, 05-July-2011.
# Purpose:
#          This script is used to generate File_list.txt which is usually
#          generated by the build system at the end of the build process.
#          File_list.txt is helpful in importing all the source files into
#          the SourceInsight/CodeWright project.
#
# Prerequisite:
#          1. Perl v5 or higher installed.
#          2. config.py mounted in a view
#
# How to Run:
#          1. Get <Root Dir>/gill_vob/6_coding in command window.
#          2. Run "perl generate_filelist_v2.0.pl"
#
# Output File:
#          1. Generated_File_list.txt - File list
#          2. Error_File_Entries.txt - Error file entries
#
################################################################################

use strict;
use Cwd;
use Cwd 'abs_path';

my $working_dir;
my $actual_path;
my $raw_filename;
my $absolute_fpath;
my $relative_fpath;

my @temp_array;

print "TCG File List Generator V2.0.\n\n";
print "Started reading config.py...\n";

open (INFILE, "config.py") or die "Unable to open config.py. Please check you are running the script in gill_vob/6_coding directory!\n";
open (OUTFILE, ">Generated_File_list.txt") or die "Unable to create output file! Make sure 6_coding directory has write access.\n";
open (ERRFILE, ">Error_File_Entries.txt") or die "Unable to create error file! Make sure 6_coding directory has write access.\n";


print "Generating File List (Generated_File_list.txt)...\n";

# Identify the build directory "M: or other drive letter".
$working_dir = cwd();

die "Please run this file in gill_vob/6_coding directory!\n" if ($working_dir !~ m/6_coding$/);

while (<INFILE>)
{
   if (m/^SourceFile/ or m/^ProjectFile/ or m/^HeaderFile/ or m/^T55File/ or m/^ModelFile/  or m/^OtherFile/  or m/^OtherheaderFile/ or m/^xmlFile/)
   {
      @temp_array = split /'/;
      $raw_filename = $temp_array[1];

      # Identify config.py
      $raw_filename =~ s/\(\.\*\\\.py\)\.\*/config\.py/g;

      # Skip tools files
      next if ($raw_filename =~ /\$ROOT/);

      # Explore the target path for all symbolic links.
      $actual_path = `cleartool describe -fmt "%[slink_text]Tp" $raw_filename`;

      if ($actual_path)
      {
         # Collect the directories in an array
         @temp_array = split /\//, $raw_filename;

         # Remove last element of the array (i.e file name)
         pop(@temp_array);

         # Assemble the path again without file name
         $raw_filename = join ("/", @temp_array);

         # Convert the path to full path (or absolute path)
         if ($raw_filename)
         {
            $relative_fpath = $raw_filename."/".$actual_path;
         }
         else
         {
            $relative_fpath = $actual_path;
         }
      }
      else
      {
         $relative_fpath = $raw_filename;
      }

      # Check if file exists
      if (-e $relative_fpath)
      {
         # Found a valid file entry
         $absolute_fpath = abs_path($relative_fpath);

         # Apply the path correction.
         $absolute_fpath =~ s/\\/\//g;

         # Print the file list entries into the output file
         print OUTFILE "$absolute_fpath\n";
      }
      else
      {
         # Error! The file entry in config.py doesn't point to any valid file.
         print ERRFILE "$raw_filename\n";
      }
   }
   else
   {
      next;
   }
}

close INFILE;
close OUTFILE;
close ERRFILE;

print "Successfully generated the file list...\n";


__END__
Version History:
1.0 - Initial version
2.0 - Error in file paths specific to evil twins are corrected.
